#!/usr/bin/python3
#
# accu-xml-tool [--html] [--adoc] [XML/HTML file]
#
# Convert an input HTML or XML file in ACCU style to AsciiDoc
# (the default) or HTML.

import argparse
import re
import sys

import bs4

class BaseOutput:
    def convert_document(self, soup):
        """ Convert the document and return the converted text."""
        return ''.join(self.convert(soup))

    def convert(self, soup):
        """ Convert everything below this tag.

        Return a list of strings.
        """
        if isinstance(soup, bs4.NavigableString):
            return self.get_string(soup.string)
        elif isinstance(soup, bs4.Tag):
            tag_name = soup.name
            if tag_name == '[document]':
                tag_name = 'document_root'
            return getattr(self, tag_name, self.unknown_tag)(soup)
        else:
            return self.convert_children(soup, replace_newlines)

    def convert_children(self, soup):
        res = []
        if soup is not None and hasattr(soup, 'children'):
            for c in soup.children:
                res.extend(self.convert(c))
        return res

    def get_string(self, s):
        return [s]

    def document_root(self, tag):
        return self.convert_children(tag)

    def unknown_tag(self, tag):
        print('Unknown Tag {}'.format(tag.name), file=sys.stderr)
        return self.convert_children(tag)

class AdocOutput(BaseOutput):
    def __init__(self):
        self.title = '(No title)'
        self.author = None
        self.bio = None
        self.ul_level = 1
        self.ol_level = 1
        self.table_level = -1
        self.table_cell_delim = ['¦', '!']
        self.table_delim_start = ['[separator=¦]\n|===', '!===']
        self.table_delim_end = ['|===', '!===']
        self.list_item = []
        self.in_pre = False
        self.in_biblio_ref = False
        self.in_biblio_re = re.compile(r'\[.+?\]\s*(?P<ref>.*)')
        self.table_listing_re = re.compile('(?P<prelude>.*)\n\\[separator=¦\\]\n\\|===\n\s*a¦\s+(?P<src>\\[source\\]\n----\n.*?\n----)\n\s*h¦Listing (?P<no>.*?)\n\\|===\n(?P<postlude>.*)', re.DOTALL)
        self.table_image_re = re.compile('(?P<prelude>.*)\n\\[separator=¦\\]\n\\|===\n\s*a¦\s+image::(?P<img>.*?)\\[\\]\n\s*h¦Figure (?P<no>.*?)\n\\|===\n(?P<postlude>.*)', re.DOTALL)

    @staticmethod
    def has_class(tag, classname):
        """ See if tag has a class of given name.

        BS behaves returns a list of classes on HTML input, and
        a single class in XML input. Deal with both.
        """
        cl = tag.get('class')
        if not cl:
            return False
        if isinstance(cl, list):
            return classname in cl
        else:
            return classname == cl

    @staticmethod
    def trim(text, spaces=True):
        while text and not text[0].strip():
            del text[0]
        while text and not text[-1].strip():
            del text[-1]
        if text:
            text[0] = text[0].lstrip('\n')
            text[-1] = text[-1].rstrip()
        if spaces and text:
            text[0] = text[0].lstrip()
        return text

    def get_string(self, s):
        if self.in_biblio_ref:
            # Remove initial [?] plus spaces.
            match = self.in_biblio_re.search(s)
            if match:
                s = match.group('ref')
        if not self.in_pre:
            # This appears to be a regular image bug.
            if s == ' />':
                s = ''
            s = s.replace('\n', ' ')\
                .replace('[', 'pass:[[]')
        s = s.replace('C++', '{cpp}')
        # TODO. Prevent character substitution on =>, <=, -> <=>.
        return [s]

    def p(self, tag):
        if self.has_class(tag, 'bio'):
            self.bio = ['\n\n.{author}\n****\n'] + self.trim(self.convert_children(tag)) + ['\n****\n']
            return []
        elif self.has_class(tag, 'quote'):
            # Tricky. We want formatted up to a line
            # starting '-', and then the rest without formatting
            # which we pray will be - <author>, <source>.
            quote = self.trim(self.convert_children(tag))
            for i in range(0, len(quote)):
                if quote[i].strip().startswith('~ '):
                    quote = quote[0:i]
                    break
            by = tag.get_text().rsplit('~ ', 1)[1].replace('\n', '')
            return ['\n\n[quote,{by}]\n____\n'.format(by=by)] + quote + ['\n____\n']
        elif self.has_class(tag, 'blockquote'):
            return ['\n\n====\n'] + self.convert_children(tag) + ['\n====\n']
        elif self.has_class(tag, 'bibliomixed'):
            # These are a single reference. The first child is the anchor.
            # This is followed by text starting with the reference '[n]',
            # then spaces and then the body of the reference, e.g.:
            #
            # <a id="[2]"></a>[2]      Principles behind the Agile Manifesto
            #
            # For AsciiDoctor we need to remove the reference text and
            # spaces, and present each reference as an item in an unordered
            # list.
            self.in_biblio_ref = True
            ref = self.convert_children(tag)
            self.in_biblio_ref = False
            return ['\n- '] + ref + ['\n']
        else:
            return ['\n\n'] + self.convert_children(tag) + ['\n']

    def code(self, tag):
        return ['`'] + self.convert_children(tag) + ['`']

    def em(self, tag):
        return ['_'] + self.convert_children(tag) + ['_']

    def strong(self, tag):
        return ['*'] + self.convert_children(tag) + ['*']

    def sup(self, tag):
        return ['^'] + self.convert_children(tag) + ['^']

    def sub(self, tag):
        return ['~'] + self.convert_children(tag) + ['~']

    def span(self, tag):
        if self.has_class(tag, 'author'):
            self.author = ''.join(self.convert_children(tag))
            return []
        else:
            return ['*'] + self.convert_children(tag) + ['*']

    def h1(self, tag):
        self.title = ''.join(self.convert_children(tag))
        return []

    def h2(self, tag):
        # A h2 block 'References' may have a bibliography...
        title = self.convert_children(tag)
        if ''.join(title) == 'References':
            return ['\n\n[bibliography]\n== '] + title + ['\n']
        else:
            return ['\n\n== '] + title + ['\n']

    def h3(self, tag):
        return ['\n\n=== '] + self.convert_children(tag) + ['\n']

    def h4(self, tag):
        return ['\n\n==== '] + self.convert_children(tag) + ['\n']

    def h5(self, tag):
        return ['\n\n===== '] + self.convert_children(tag) + ['\n']

    def h6(self, tag):
        return ['\n\n====== '] + self.convert_children(tag) + ['\n']

    def pre(self, tag):
        self.in_pre = True
        src = self.convert_children(tag)
        self.in_pre = False
        return ['\n\n[source]\n----\n'] + self.trim(src, False) + ['\n----\n']

    def br(self, tag):
        return [' +\n']

    def ul(self, tag):
        self.list_item.append('*' * self.ul_level)
        self.ul_level += 1
        res = self.convert_children(tag)
        self.ul_level -= 1
        self.list_item.pop()
        return res

    def ol(self, tag):
        self.list_item.append('.' * self.ol_level)
        self.ol_level += 1
        res = self.convert_children(tag)
        self.ol_level -= 1
        self.list_item.pop()
        return res

    def li(self, tag):
        return ['\n{} '.format(self.list_item[-1])] + self.convert_children(tag)

    def table(self, tag):
        self.table_level += 1
        if self.table_level >= len(self.table_cell_delim):
            print('Sorry, I can\'t nest tables that deep.', file=sys.stderr)
            sys.exit(1)
        sidebar = self.has_class(tag, 'sidebartable')
        if sidebar:
            res = ['\n\n****\n{}\n'.format(self.table_delim_start[self.table_level])]
        else:
            res = ['\n\n{}\n'.format(self.table_delim_start[self.table_level])]
        res = res + self.trim(self.convert_children(tag))
        if sidebar:
            res = res + ['\n{}\n****\n'.format(self.table_delim_end[self.table_level])]
        else:
            res = res + ['\n{}\n'.format(self.table_delim_end[self.table_level])]
        self.table_level -= 1

        # Look out for particular table formations and replace with
        # more appropriate markup.
        s = ''.join(res)
        match = self.table_listing_re.fullmatch(s)
        if match:
            return [ '{prelude}\n.Listing {no}\n{src}\n{postlude}'.format(
                prelude=match.group('prelude'),
                src=match.group('src'),
                no=match.group('no'),
                postlude=match.group('postlude')) ]
        match = self.table_image_re.fullmatch(s)
        if match:
            return [ '{prelude}\n.Figure {no}\nimage::{img}[Figure {no}]\n{postlude}'.format(
                prelude=match.group('prelude'),
                img=match.group('img'),
                no=match.group('no'),
                postlude=match.group('postlude')) ]
        return res

    def tr(self, tag):
        return ['\n'] + self.convert_children(tag)

    def td(self, tag):
        if self.has_class(tag, 'title'):
            res = [' h{}'.format(self.table_cell_delim[self.table_level])]
        else:
            res = [' a{}'.format(self.table_cell_delim[self.table_level])]
        return res + self.convert_children(tag)

    def th(self, tag):
        return [' h{}'.format(self.table_cell_delim[self.table_level])] + self.convert_children(tag)

    def a(self, tag):
        id = tag.get('id')
        if id:
            if id[0] == '[' and id[-1] == ']':
                # It's a bibliography entry. These should have no content.
                id = id[1:-1]
                return ['[[[ref{id},{id}]]] '.format(id=id)]
            else:
                # Define an anchor.
                return ['[[ref{id},{id}]] '.format(id=id)] + self.convert_children(tag)
        href = tag.get('href')
        if href:
            if href.startswith('#[') and href.endswith(']'):
                # It's a biblio reference. Add reference. The content should
                # just repeat the reference.
                return ['<<ref{ref}>>'.format(ref=href[2:-1])]
            else:
                # It's a regular link.
                return ['link:{url}['.format(url=href)] + self.convert_children(tag) + [']']

    def img(self, tag):
        src = tag.get('src')
        if src.startswith('http://accu.org'):
            src = src.replace('http://accu.org/content/images/', '', 1)
        return ['\nimage::{src}[]\n'.format(src=src)]

    def html(self, tag):
        return self.convert_children(tag)

    def xml(self, tag):
        return self.convert_children(tag)

    def convert_document(self, soup):
        """ Convert the document and return the converted text."""
        body = self.convert(soup)
        res = [ '= {title}\n'.format(title=self.title) ]
        if self.author:
            res = res + [ ':author: {author}\n'.format(author=self.author) ]
        res = res + [ ':imagesdir: https://accu.org/content/images/\n:figure-caption!:\n' ] + body
        if self.bio:
            res = res + self.bio
        return ''.join(res)

class HtmlOutput(BaseOutput):
    pass

def convert_file(f, input, output):
    soup = bs4.BeautifulSoup(f, input)
    res = output.convert_document(soup)
    print(res)

def main():
    parser = argparse.ArgumentParser(description='convert ACCU XML/HTML.')
    parser.add_argument('--input-format', dest='input_format', action='store',
                        choices=['html', 'xml'], default='xml',
                        help='input format - html or xml', metavar='FORMAT')
    parser.add_argument('--output-format', dest='output_format', action='store',
                        choices=['html', 'adoc'], default='adoc',
                        help='output format - adoc or html', metavar='FORMAT')
    parser.add_argument('input', type=argparse.FileType('r'),
                        help='input XML or HTML file',
                        metavar='XML/HTML file')
    args = parser.parse_args()

    parsers = {
        "xml": "lxml-xml",
        "html": "lxml"
        }
    outputs = {
        "adoc": AdocOutput(),
        "html": HtmlOutput()
    }

    convert_file(args.input, parsers[args.input_format], outputs[args.output_format])


if __name__ == "__main__":
    main()

# Local Variables:
# mode: Python
# End:
